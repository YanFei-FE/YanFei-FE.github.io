<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>前高频端面试题合集24-vue基本语法使用 | </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1. 路由1.1 router的使用方式 在router&#x2F;index.js的文件中引入vue-router,Vue.use(VueRouter)  new VueRouter 导出  创建vue实例的地方，引入router  在具体的页面中使用router-link标签 :to属性配置path或者name query或者 params  使用router-view标签展示link的链接的组件">
<meta property="og:type" content="article">
<meta property="og:title" content="前高频端面试题合集24-vue基本语法使用">
<meta property="og:url" content="https://yanfei.me/%E5%89%8D%E9%AB%98%E9%A2%91%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%8624-vue%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%BD%BF%E7%94%A8/index.html">
<meta property="og:site_name">
<meta property="og:description" content="1. 路由1.1 router的使用方式 在router&#x2F;index.js的文件中引入vue-router,Vue.use(VueRouter)  new VueRouter 导出  创建vue实例的地方，引入router  在具体的页面中使用router-link标签 :to属性配置path或者name query或者 params  使用router-view标签展示link的链接的组件">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yanfei.me/%E5%89%8D%E9%AB%98%E9%A2%91%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%8624-vue%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%BD%BF%E7%94%A8/image-20210521142603087.png">
<meta property="og:image" content="https://yanfei.me/%E5%89%8D%E9%AB%98%E9%A2%91%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%8624-vue%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%BD%BF%E7%94%A8/image-20210521142651656.png">
<meta property="og:image" content="https://yanfei.me/%E5%89%8D%E9%AB%98%E9%A2%91%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%8624-vue%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%BD%BF%E7%94%A8/image-20210619181015456.png">
<meta property="og:image" content="https://yanfei.me/%E5%89%8D%E9%AB%98%E9%A2%91%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%8624-vue%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%BD%BF%E7%94%A8/image-20210619184557064.png">
<meta property="og:image" content="https://yanfei.me/%E5%89%8D%E9%AB%98%E9%A2%91%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%8624-vue%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%BD%BF%E7%94%A8/生命周期图.png">
<meta property="article:published_time" content="2021-11-03T09:38:18.000Z">
<meta property="article:modified_time" content="2021-11-03T10:43:42.936Z">
<meta property="article:author" content="Yan Fei">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="VUE">
<meta property="article:tag" content="前高频端面试题合集">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yanfei.me/%E5%89%8D%E9%AB%98%E9%A2%91%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%8624-vue%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%BD%BF%E7%94%A8/image-20210521142603087.png">
  
    <link rel="alternate" href="/atom.xml" title="" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo"></a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">时间轴</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://yanfei.me"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-前高频端面试题合集24-vue基本语法使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/%E5%89%8D%E9%AB%98%E9%A2%91%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%8624-vue%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%BD%BF%E7%94%A8/" class="article-date">
  <time datetime="2021-11-03T09:38:18.000Z" itemprop="datePublished">2021-11-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      前高频端面试题合集24-vue基本语法使用
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-路由"><a href="#1-路由" class="headerlink" title="1. 路由"></a>1. 路由</h2><h3 id="1-1-router的使用方式"><a href="#1-1-router的使用方式" class="headerlink" title="1.1 router的使用方式"></a>1.1 router的使用方式</h3><ol>
<li><p>在router/index.js的文件中引入vue-router,Vue.use(VueRouter)</p>
</li>
<li><p>new VueRouter 导出</p>
</li>
<li><p>创建vue实例的地方，引入router</p>
</li>
<li><p>在具体的页面中使用router-link标签 :to属性配置path或者name query或者 params</p>
</li>
<li><p>使用router-view标签展示link的链接的组件</p>
</li>
</ol>
<h3 id="1-2-router跳转-传参"><a href="#1-2-router跳转-传参" class="headerlink" title="1.2 router跳转+传参"></a>1.2 router跳转+传参</h3><h4 id="1-2-1-路由跳转的四种方式"><a href="#1-2-1-路由跳转的四种方式" class="headerlink" title="1.2.1 路由跳转的四种方式"></a>1.2.1 路由跳转的四种方式</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;home&#x27;&#125;&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;path:&#x27;/home&#x27;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">this.$router.push(&#x27;/home&#x27;)</span><br><span class="line">this.$router.push(&#123;name:&#x27;home&#x27;&#125;)</span><br><span class="line">this.$router.push(&#123;path:&#x27;/home&#x27;&#125;)</span><br><span class="line">this.$router.replace()  <span class="comment">// (用法同上,push)</span></span><br><span class="line">this.$router.go(n)      <span class="comment">// n是n可为正整数或负整数</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-路由传参的三种方式"><a href="#1-2-2-路由传参的三种方式" class="headerlink" title="1.2.2 路由传参的三种方式"></a>1.2.2 路由传参的三种方式</h4><ol>
<li><p>路径带？key=value</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about?id=1&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>query 相当于get</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;path:&#x27;/query&#x27;,query:&#123;id:12&#125;&#125;&quot;</span>&gt;</span>带参数query<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>params 相当于post</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name:&#x27;Params&#x27;,params:&#123;id:11&#125;&#125;&quot;</span>&gt;</span>带参数params<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="1-2-3-获取路由参数的方法"><a href="#1-2-3-获取路由参数的方法" class="headerlink" title="1.2.3 获取路由参数的方法"></a>1.2.3 获取路由参数的方法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路径传参和query属性传参，都用该方式获取参数</span></span><br><span class="line"><span class="built_in">this</span>.$route.query.val</span><br><span class="line"><span class="comment">// params属性传参，用该方式获取</span></span><br><span class="line"><span class="built_in">this</span>.$route.params.val</span><br></pre></td></tr></table></figure>

<h3 id="1-3-动态路由"><a href="#1-3-动态路由" class="headerlink" title="1.3  动态路由"></a>1.3  动态路由</h3><p>作用：多个路由对应同一个组件，根据路由配置id不同，获取不同参数，进行相应处理</p>
<h3 id="1-4-路由嵌套"><a href="#1-4-路由嵌套" class="headerlink" title="1.4  路由嵌套"></a>1.4  路由嵌套</h3><p>作用：一个页面某个位置根据链接不同，展示不同的组件，例如项目中的店家</p>
<p>展示默认子路由方法：在嵌套路由父路由中添加redirect属性，值为子路由的值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redirect: <span class="string">&#x27;/childrouter&#x27;</span>,</span><br></pre></td></tr></table></figure>

<h3 id="1-5-路由懒加载-按需加载"><a href="#1-5-路由懒加载-按需加载" class="headerlink" title="1.5 路由懒加载/ 按需加载"></a>1.5 路由懒加载/ 按需加载</h3><p>作用：性能优化：不用到该路由，不加载该组件 </p>
<p>ES6的impot方式:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;about&quot; */</span> <span class="string">&#x27;../views/About.vue&#x27;</span>),</span><br></pre></td></tr></table></figure>

<p>VUE中的异步组件进行懒加载方式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">component: resolve=&gt;(require([&#x27;../views/About&#x27;],resolve))</span><br></pre></td></tr></table></figure>

<h2 id="2-v-show和v-if"><a href="#2-v-show和v-if" class="headerlink" title="2. v-show和v-if"></a>2. v-show和v-if</h2><ul>
<li>作用: 都是控制元素隐藏和显示的</li>
<li>区别：<ul>
<li>v-show: 控制的元素无论是true还是false，都被渲染出来了，通过display：none控制元素隐藏</li>
<li>v-if: 控制的元素是true，进行渲染，如果是false不渲染，根本在dom树结构中不显示</li>
</ul>
</li>
<li>应用：<ul>
<li>v-show: 适合使用在切换频繁显示/隐藏的元素上</li>
<li>v-if: 适合使用在切换不频繁，且元素内容很多，渲染一次性能消耗很大的元素上</li>
</ul>
</li>
</ul>
<h2 id="3-v-for-为什么要加key"><a href="#3-v-for-为什么要加key" class="headerlink" title="3. v-for 为什么要加key"></a>3. v-for 为什么要加key</h2><p> v-for 为什么一定要加key，且key要不同</p>
<ol>
<li><p>加key是为了给元素添加唯一标识，因为vue是虚拟dom，用diff算法对节点进行一一比对，要修改哪个元素，这个元素一定要有一个唯一标识，为了性能优化,比如修改了原数组，没有给li上加key，那么在进行运算的时候，就重新将整体渲染一遍，但是如果有key，那么它就会按照key找到修改内容的那个li元素，改掉它自己，不需要对其他元素进行修改</p>
<img src="image-20210521142603087.png" alt="image-20210521142603087" style="zoom:67%;" /></li>
</ol>
<img src="image-20210521142651656.png" alt="image-20210521142651656" style="zoom:67%;" />

<ol start="2">
<li>key为什么不能是index，因为假设我们给数组前插入一个新元素，它的下标是0，那么和原来的第一个元素重复了，整个数组的key都发生了改变，这样就跟没有key的情况一样了</li>
</ol>
<img src="image-20210619181015456.png" alt="image-20210619181015456" style="zoom:50%;" />



<h2 id="4-keepalive"><a href="#4-keepalive" class="headerlink" title="4. keepalive"></a>4. keepalive</h2><ol>
<li><p>默认情况下加在keepalive标签中的组件都会进行缓存</p>
</li>
<li><p>为了区别缓存哪些组件的方法</p>
<p>   给keepalive 添加属性，组件名称指的是具体组件添加的name，不是路由里面的name</p>
<p>   include 包含的组件(可以为字符串，数组，以及正则表达式,只有匹配的组件会被缓存)</p>
<p>   exclude 排除的组件(以为字符串，数组，以及正则表达式,任何匹配的组件都不会被缓存)</p>
<p>   最常用的方式：和路由配合使用：在路由中添加meta属性，美团项目App.vue</p>
</li>
<li><p>keepalive作用：提升性能，避免重复加载一些不需要经常变动且内容较多的组件</p>
</li>
<li><p>使用keepalive导致组件不重新加载，也就不会重新执行生命周期的函数，如果要解决这个问题，就需要两个属性进入时触发：activated 退出时触发：deactivated</p>
</li>
</ol>
<h2 id="5-data-为什么是函数"><a href="#5-data-为什么是函数" class="headerlink" title="5. data 为什么是函数"></a>5. data 为什么是函数</h2><p>vue组件中data值不能为对象，因为对象是引用类型，组件可能会被多个实例同时引用。如果data值为对象，将导致多个实例共享一个对象，其中一个组件改变data属性值，其它实例也会受到影响</p>
<p>data是一个函数的话，这样每复用一次组件，就会返回一份新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果。</p>
<p>所以说vue组件的data必须是函数。这都是因为js的特性带来的，跟vue本身设计无关。</p>
<h2 id="6-为什么style中加scoped"><a href="#6-为什么style中加scoped" class="headerlink" title="6. 为什么style中加scoped"></a>6. 为什么style中加scoped</h2><p> 区分样式的作用域，原理是加上scoped就会给当前组件添加上自定义属性，同时选择器上会添加自定义属性进行样式设置</p>
<p><img src="image-20210619184557064.png" alt="image-20210619184557064"></p>
<h2 id="7-computed-watch的区别"><a href="#7-computed-watch的区别" class="headerlink" title="7. computed /watch的区别"></a>7. computed /watch的区别</h2><h3 id="7-1-computed"><a href="#7-1-computed" class="headerlink" title="7.1 computed"></a>7.1 computed</h3><ul>
<li>初始化显示或者相关的 data、props 等属性数据发生变化的时候调用；</li>
<li>将复杂的计算逻辑从模板中抽离出来，使模板变得更加简洁 </li>
<li>计算属性不在 data 中，它是基于data 或 props 中的数据通过计算得到的一个新值，这个新值根据已知值的变化而变化；</li>
<li>在 computed 属性对象中定义计算属性的方法，和取data对象里的数据属性一样，以属性访问的形式调用；</li>
<li><strong>computed中的方法只有依赖的数据发生改变的时候才会执行,且计算的结果会缓存起来</strong>，更像是input的keyup事件，获取到value值进行比对之后再触发</li>
<li>在computed中的，属性都有一个 get 和一个 set 方法，当数据变化时，调用 set 方法</li>
</ul>
<h3 id="7-2-watch"><a href="#7-2-watch" class="headerlink" title="7.2 watch"></a>7.2 watch</h3><ul>
<li>主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作，可以看作是 computed 和 methods 的结合体；</li>
<li>可以监听的数据来源：data，props，computed内的数据；</li>
<li>watch<strong>支持异步</strong>；</li>
<li><strong>不支持缓存</strong>，监听的数据改变，直接会触发相应的操作；更像是input的change事件，输入就触发，不比对</li>
<li>监听函数有两个参数，第一个参数是最新的值，第二个参数是输入之前的值，顺序一定是新值，旧值。</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><strong>computed：</strong> 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</p>
<p><strong>watch：</strong> 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p>
<p><strong>运用场景：</strong></p>
<ul>
<li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li>
<li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>
</ul>
<h2 id="8-组件传值"><a href="#8-组件传值" class="headerlink" title="8. 组件传值"></a>8. 组件传值</h2><h3 id="8-1-父子组件"><a href="#8-1-父子组件" class="headerlink" title="8.1 父子组件"></a>8.1 父子组件</h3><h4 id="8-1-1-父子组件使用"><a href="#8-1-1-父子组件使用" class="headerlink" title="8.1.1 父子组件使用"></a>8.1.1 父子组件使用</h4><ol>
<li><p>import引入</p>
</li>
<li><p>components中注入</p>
<ol start="3">
<li>在template中上写子组件标签</li>
</ol>
</li>
</ol>
<h4 id="8-1-2-父子组件传值方式"><a href="#8-1-2-父子组件传值方式" class="headerlink" title="8.1.2 父子组件传值方式"></a>8.1.2 父子组件传值方式</h4><ol>
<li><p>父亲给子组件传递数据或者方法： 在组件上&lt;List :list=”list” @delete=”deleteHandler”/&gt;</p>
</li>
<li><p>子组件使用父亲传递的数据：props属性,调用父组件传递的方法this.$emit(‘方法名’,参数)</p>
<p>props是只读，不可以被修改，所有被修改都会失效和被警告</p>
</li>
</ol>
<h3 id="8-2-不相关两个组件或者兄弟组件通信：emit发布-，on接受"><a href="#8-2-不相关两个组件或者兄弟组件通信：emit发布-，on接受" class="headerlink" title="8.2 不相关两个组件或者兄弟组件通信：emit发布 ，on接受"></a>8.2 不相关两个组件或者兄弟组件通信：emit发布 ，on接受</h3><p>​      event.$emit(‘名称’,参数)</p>
<p>​      event.$on(‘名称’,方法)</p>
<p>​      event</p>
<h2 id="9-生命周期"><a href="#9-生命周期" class="headerlink" title="9. 生命周期"></a>9. 生命周期</h2><img src="生命周期图.png" alt="生命周期图" style="zoom:50%;" />

<h3 id="9-1-单页面生命周期"><a href="#9-1-单页面生命周期" class="headerlink" title="9.1 单页面生命周期"></a>9.1 单页面生命周期</h3><p>​    1. 生命周期是用来描述一个组件从引入到退出的全过程</p>
<p>​    2. 生命周期核心的几步：挂在阶段=&gt;更新阶段=&gt;销毁阶段</p>
<p>​    3. 挂载阶段：beforeCreate、created、beforeMounted、mounted</p>
<p>​      更新阶段：beforeUpdate、updated</p>
<p>​      销毁阶段：beforeDestroy、destroyed</p>
<p>​    4. 重点阶段适合做什么</p>
<p>​      created：实例创建完成，可访问data、computed、watch、methods上的方法和数据，未挂载到DOM，</p>
<p>​      不能访问到el属性，el属性，ref属性内容为空数组常用于简单的ajax请求，页面的初始化</p>
<p>​      beforeMount</p>
<p>​      在挂载开始之前被调用，beforeMount之前，会找到对应的template，并编译成render函数</p>
<p>​      mounted</p>
<p>​      实例挂载到DOM上，此时可以通过DOM API获取到DOM节点，$ref属性可以访问</p>
<p>​      常用于获取VNode信息和操作，ajax请求</p>
<p>​      beforeupdate</p>
<p>​      响应式数据更新时调用，发生在虚拟DOM打补丁之前</p>
<p>​      适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器</p>
<p>​      updated</p>
<p>​      虚拟 DOM 重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作</p>
<p>​      避免在这个钩子函数中操作数据，可能陷入死循环</p>
<p>​      beforeDestroy</p>
<p>​      实例销毁之前调用。这一步，实例仍然完全可用，this仍能获取到实例</p>
<p>​      常用于销毁定时器、解绑全局事件、销毁插件对象等操作</p>
<h3 id="9-2-父子组件生命周期"><a href="#9-2-父子组件生命周期" class="headerlink" title="9.2 父子组件生命周期"></a>9.2 父子组件生命周期</h3><p>​    1. 挂载：父亲created&gt; 子created &gt; 子mounted&gt; 父亲mounted&gt; </p>
<p>​    2. 更新：父亲beforeUpdate &gt; 子beforeUpdated &gt; 子updated &gt; 父亲updated</p>
<p>​    3. 销毁：父亲beforeDestroy&gt; 子beforeDestroy &gt; 子destroyed&gt; 父destroyed</p>
<p>​    </p>
<h2 id="10-请求放在哪个生命周期更合适"><a href="#10-请求放在哪个生命周期更合适" class="headerlink" title="10. 请求放在哪个生命周期更合适"></a>10. 请求放在哪个生命周期更合适</h2><p>​    为什么不在 created 里去发ajax？created 可是比 mounted 更早调用啊，更早调用意味着更早返回结果，那样性能不是更高？</p>
<p>​    1. 一个组件的 created 比 mounted 也早调用不了几微秒，性能没啥提高；</p>
<p>​    2. 等到异步渲染开启的时候，created 就可能被中途打断，中断之后渲染又要重做一遍，</p>
<p>​    在 created 中做ajax调用，代码里看到只有调用一次，但是实际上可能调用 N 多次，这明显不合适。</p>
<p>​    3. 若把发ajax 放在 mounted，因为 mounted 在第二阶段，所以绝对不会多次重复调用，这才是ajax合适的位置.</p>
<p>​    4. 在created的时候，视图中的dom并没有被渲染出来，所以此时如果直接去操作dom节点，无法找到相关元素。</p>
<p>​      在mounted中，由于此时的dom元素已经渲染出来了，所以可以直接使用dom节点。</p>
<p>​    一般情况下，都放在mounted中，保证逻辑的统一性。因为生命周期是同步执行的，ajax是异步执行的。</p>
<p>​    服务端渲染不支持mounted方法，所以在服务端渲染的情况下统一放在created中。</p>
<h2 id="11-nextTick"><a href="#11-nextTick" class="headerlink" title="11. $nextTick"></a>11. $nextTick</h2><p>在钩子函数created()里面想要获取dom的内容或者操作dom，但是这个时候只是虚拟dom，实际dom操作不了，所以在这里可以用this.$nextTick()，这样等dom更新完了再执行this.$nextTick()里面的回调，这样就可以操作或者获取dom的内容了</p>
<h2 id="12-VueX基本使用"><a href="#12-VueX基本使用" class="headerlink" title="12. VueX基本使用"></a>12. VueX基本使用</h2><h3 id="12-1-vuex的作用"><a href="#12-1-vuex的作用" class="headerlink" title="12.1 vuex的作用"></a>12.1 vuex的作用</h3><p>集中管理项目公共数据</p>
<h3 id="12-2-本来就是单页面应用，为什么不创建一个全局变量来代替vuex"><a href="#12-2-本来就是单页面应用，为什么不创建一个全局变量来代替vuex" class="headerlink" title="12.2 本来就是单页面应用，为什么不创建一个全局变量来代替vuex"></a>12.2 本来就是单页面应用，为什么不创建一个全局变量来代替vuex</h3><ol>
<li><p>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p>
</li>
<li><p>不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用</p>
</li>
</ol>
<h3 id="12-3-使用方法"><a href="#12-3-使用方法" class="headerlink" title="12.3 使用方法"></a>12.3 使用方法</h3><ol>
<li><p> 和vue-router使用方式一样，先引入，再use，然后new vuex.store实例，然后将该实例注入到Vue实例中</p>
</li>
<li><p> 创建数据 state</p>
</li>
</ol>
<p>​        state: {</p>
<p>​          count: 0</p>
<p>​        },</p>
<ol start="3">
<li>获取state中数据的方式</li>
</ol>
<p>​        a.直接在虚拟dom上使用</p>
<p>​        b.在computed中定义方法，返回this.$store.state.count</p>
<p>​         在页面</p>
<p>​        c.批量获取state中的数据       </p>
<ol start="4">
<li>修改state数据 mutations 和 commit</li>
</ol>
<p>​        在mutations中定义方法没使用this.$store.commit(‘方法名称’,参数)修改state中的数据</p>
<p>​        …mapMutation获取多个方法</p>
<p>​        注意：不要在mutation中的方法中写异步方法：ajax，那样数据就不可跟踪了 </p>
<ol start="5">
<li><p>getters : 如果state中的数据需要有被处理过的，我们需要一个固定处理数据的方法，同时这个方法保证，state中的数据发生改变，他就跟着改变，类似与computed方法    </p>
</li>
<li><p>Action : 定义调用mutations中方法的方法，为了能在改变state中值之前使用一些异步方法</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <!-- <a data-url="https://yanfei.me/%E5%89%8D%E9%AB%98%E9%A2%91%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%8624-vue%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%BD%BF%E7%94%A8/" data-id="ckvoyr7we000w44mhfe5c0df0" class="article-share-link">分享</a> -->
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VUE/" rel="tag">VUE</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%89%8D%E9%AB%98%E9%A2%91%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86/" rel="tag">前高频端面试题合集</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/%E5%89%8D%E9%AB%98%E9%A2%91%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%8625-vue%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          前高频端面试题合集25-vue相关原理
        
      </div>
    </a>
  
  
    <a href="/%E5%89%8D%E9%AB%98%E9%A2%91%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%8623-%E8%A7%82%E5%AF%9F%E8%80%85%E4%B8%8E%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E8%80%85%E6%A8%A1%E5%BC%8F/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">前高频端面试题合集23-观察者与发布订阅者模式</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS3/" rel="tag">CSS3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAScript6/" rel="tag">ECMAScript6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ECMAScript7-ECMAScript11/" rel="tag">ECMAScript7 - ECMAScript11</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML5/" rel="tag">HTML5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VUE/" rel="tag">VUE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E9%AB%98%E9%A2%91%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86/" rel="tag">前高频端面试题合集</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS3/" style="font-size: 10px;">CSS3</a> <a href="/tags/ECMAScript6/" style="font-size: 16px;">ECMAScript6</a> <a href="/tags/ECMAScript7-ECMAScript11/" style="font-size: 10px;">ECMAScript7 - ECMAScript11</a> <a href="/tags/HTML5/" style="font-size: 10px;">HTML5</a> <a href="/tags/VUE/" style="font-size: 12px;">VUE</a> <a href="/tags/%E5%89%8D%E9%AB%98%E9%A2%91%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%86/" style="font-size: 18px;">前高频端面试题合集</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">笔记</a> <a href="/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 14px;">网络</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">十二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">六月 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/%E5%89%8D%E9%AB%98%E9%A2%91%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%8625-vue%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/">前高频端面试题合集25-vue相关原理</a>
          </li>
        
          <li>
            <a href="/%E5%89%8D%E9%AB%98%E9%A2%91%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%8624-vue%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E4%BD%BF%E7%94%A8/">前高频端面试题合集24-vue基本语法使用</a>
          </li>
        
          <li>
            <a href="/%E5%89%8D%E9%AB%98%E9%A2%91%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%8623-%E8%A7%82%E5%AF%9F%E8%80%85%E4%B8%8E%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E8%80%85%E6%A8%A1%E5%BC%8F/">前高频端面试题合集23-观察者与发布订阅者模式</a>
          </li>
        
          <li>
            <a href="/%E5%89%8D%E9%AB%98%E9%A2%91%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%8622-%E5%AE%89%E5%85%A8/">前高频端面试题合集22-安全</a>
          </li>
        
          <li>
            <a href="/%E5%89%8D%E9%AB%98%E9%A2%91%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%90%88%E9%9B%8621-%E7%BB%A7%E6%89%BF%20%E4%B8%8E%20%E5%8E%9F%E5%9E%8B%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE/">前高频端面试题合集21-继承 与 原型、原型链</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 Yan Fei<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">时间轴</a>
  
</nav>
    

<script src="https://code.jquery.com/jquery-2.0.3.min.js" integrity="sha256-sTy1mJ4I/LAjFCCdEB4RAvPSmRCb3CU7YqodohyeOLo=" crossorigin="anonymous"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>